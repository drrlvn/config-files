fpath=(~/.zsh "${0:h}/zsh-completions/src" $fpath)

unsetopt flow_control
setopt extended_glob
setopt correct
setopt numeric_glob_sort
setopt rc_expand_param
setopt complete_in_word
setopt always_to_end
unsetopt nomatch
setopt prompt_subst

# pushd options
setopt auto_cd
setopt auto_pushd
setopt pushd_silent
setopt pushd_to_home
setopt pushd_ignore_dups

# history options
HISTFILE=~/.history
SAVEHIST=10000
HISTSIZE=20000

setopt append_history
setopt extended_history
setopt hist_expire_dups_first
setopt hist_fcntl_lock
setopt hist_find_no_dups
setopt hist_ignore_space
setopt hist_no_store
setopt hist_reduce_blanks
setopt inc_append_history

bindkey -e

autoload -Uz add-zsh-hook compinit edit-command-line promptinit url-quote-magic zargs zcalc zmv
zmodload zsh/deltochar
compinit -i
promptinit; prompt spatz

set_abbrev_pwd() {
    local pwd="${PWD/#$HOME/~}"
    _abbrev_pwd="${${(M)pwd:#[/~]}:-${${${${(@j:/:M)${(@s:/:)pwd}##.#?}:h}%/}//\%/%%}/${${pwd:t}//\%/%%}}"
}
add-zsh-hook chpwd set_abbrev_pwd
set_abbrev_pwd

redraw-prompt() {
    local precmd
    for precmd in $precmd_functions; do
        $precmd
    done
    zle reset-prompt
}
zle -N redraw-prompt

expand-or-complete-with-dots() {
    print -Pn "%B%F{red}...%f%b"
    zle expand-or-complete
    zle redisplay
}
zle -N expand-or-complete-with-dots
bindkey "\C-I" expand-or-complete-with-dots

zle -N edit-command-line
bindkey '\C-x\C-e' edit-command-line

zle -N self-insert url-quote-magic

zmodload zsh/terminfo

bindkey ';3D' emacs-backward-word
bindkey ';5D' emacs-backward-word
bindkey '[D' emacs-backward-word
bindkey '[1;3D' emacs-backward-word
bindkey '[1;5D' emacs-backward-word
bindkey ';3C' emacs-forward-word
bindkey ';5C' emacs-forward-word
bindkey '[C' emacs-forward-word
bindkey '[1;3C' emacs-forward-word
bindkey '[1;5C' emacs-forward-word

bindkey '[5~' history-beginning-search-backward
bindkey '[6~' history-beginning-search-forward

bindkey "$terminfo[khome]" beginning-of-line
bindkey "$terminfo[kend]" end-of-line
bindkey "$terminfo[kdch1]" delete-char
bindkey '[3;3~' delete-word

bindkey '\ez' delete-to-char
bindkey '\e;' copy-prev-shell-word

# Meta-u to chdir to the parent directory
goto-parent() { cd .. ; zle redraw-prompt }
zle -N goto-parent
bindkey '\eu' goto-parent
# Meta-h goes home
goto-home() { cd ; dirs -c ; zle redraw-prompt }
zle -N goto-home
bindkey '\eh' goto-home
# Meta-p pops the dir stack
pop-dir() { popd &> /dev/null && zle redraw-prompt }
zle -N pop-dir
bindkey '\ep' pop-dir
# Meta-s to insert sudo in the beginning of the line
prepend-sudo() {
    if [[ "$BUFFER" != su(do|)\ * ]]; then
        BUFFER="sudo $BUFFER"
        (( CURSOR += 5 ))
    fi
}
zle -N prepend-sudo
bindkey '\es' prepend-sudo
# Meta-r to delete command
bindkey -s '\er' '^Ad'

bindkey ' ' magic-space

# bind C-M-{Left,Right} to cycle through dir stack
cycle-dir-left() { pushd -0 && zle redraw-prompt }
zle -N cycle-dir-left
bindkey '\e[1;7C' cycle-dir-left
cycle-dir-right() { pushd +1 &> /dev/null && zle redraw-prompt }
zle -N cycle-dir-right
bindkey '\e[1;7D' cycle-dir-right

if [[ $TERM = "xterm-termite" ]]; then
    eval $(dircolors -b <(dircolors -p | sed '/^TERM xterm$/a TERM xterm-termite'))
else
    eval $(dircolors -b)
fi

# update window title
set-window-title() {
    local title_formatted
    zformat -f title_formatted "%s" "s:$argv"
    printf "\e]2;%s\a" "${(V%)title_formatted}"
}

set_title_to_path() {
    set-window-title "$_abbrev_pwd"
}
add-zsh-hook precmd set_title_to_path

set_title_to_command() {
    local cmd="${${2[(wr)^(*=*|sudo|ssh|-*)]}:t}"
    set-window-title "$cmd"
}
add-zsh-hook preexec set_title_to_command

# enable cache
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

zstyle ':completion:*' menu select=1 _complete _ignored _approximate
zstyle ':completion:*' list-dirs-first 'yes'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:matches' group 'yes'
zstyle ':completion:*:descriptions' format ' %B%F{yellow}-- %d --%f%b'
zstyle ':completion:*:corrections' format ' %B%F{green}-- %d (errors: %e) --%f%b'
zstyle ':completion:*:messages' format ' %B%F{purple} -- %d --%f%b'
zstyle ':completion:*:warnings' format ' %B%F{red}-- no matches found --%f%b'
zstyle ':completion:*' verbose yes

# enable fuzzy matching when completing
zstyle ':completion:*' completer _complete _match _approximate
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric

# highlight differing character of completions
zstyle -e ':completion:*:default' list-colors 'reply=("${PREFIX:+=(#bi)($PREFIX:t)(?)*==02=01}:${(s.:.)LS_COLORS}")'

zstyle ':completion:*:*:cd:*' tag-order local-directories directory-stack path-directories
zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'
zstyle ':completion:*:functions' ignored-patterns '(_*)'

zstyle ':completion:*:manuals' separate-sections true
zstyle ':completion:*:manuals.(^1*)' insert-sections true

zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;36=0=01'
zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:*:kill:*' force-list always
zstyle ':completion:*:*:kill:*' insert-ids single

WORDCHARS=${WORDCHARS//\/}
READNULLCMD=less

PATH="${HOME}/bin:${PATH}"
if hash ruby 2>/dev/null; then
    PATH="$PATH:$(ruby -e 'print Gem.user_dir')/bin"
fi

export LESS="-R -n -F -X"

alias gg='git grep'

alias grep='grep --color=auto'
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -Iv'
alias ls='ls --color=auto --group-directories-first -lFhX'
alias la='ls -A'
alias tree='tree --dirsfirst'
alias reload='rehash; source ~/.zshrc'

# enable zsh-history-substring-search
. "${0:h}/zsh-history-substring-search/zsh-history-substring-search.zsh"
bindkey "[A" history-substring-search-up
bindkey "[B" history-substring-search-down

# enable zsh-syntax-highlighting
. "${0:h}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
ZSH_HIGHLIGHT_STYLES[globbing]='fg=blue,bold'
ZSH_HIGHLIGHT_STYLES[history-expansion]='fg=blue,bold'

# enable fasd
PATH="${PATH}:${0:h}/fasd"
eval "$(fasd --init auto)"

# enable command-not-found hook on arch
[[ -f /usr/share/doc/pkgfile/command-not-found.zsh ]] && source /usr/share/doc/pkgfile/command-not-found.zsh
